<!DOCTYPE html>
<html lang="zh-TW">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>ç¥ç§˜é›»å­ç›’</title>
    <style>
        /* 1. åŸºç¤è¨­å®š */
        html, body {
            margin: 0; padding: 0;
            background-color: #f0f4f8; 
            font-family: -apple-system, BlinkMacSystemFont, "Segoe UI", Roboto, Arial, sans-serif;
            overscroll-behavior: none; 
            -webkit-tap-highlight-color: transparent;
        }

        .main-container {
            display: flex;
            flex-direction: column;
            align-items: center;
            width: 100%;
            padding: 10px;
            box-sizing: border-box;
            padding-bottom: 80px;
        }

        h1 { color: #2c3e50; margin: 10px 0; font-size: 22px; text-align: center; }
        
        .intro {
            background: white;
            padding: 10px 20px;
            border-radius: 10px;
            color: #555;
            font-size: 0.95rem;
            text-align: center;
            margin-bottom: 15px;
            border-left: 5px solid #3498db;
            max-width: 800px;
            line-height: 1.5;
        }

        /* 2. é›™å€åŸŸä½ˆå±€ */
        .lab-wrapper {
            display: flex;
            flex-wrap: wrap; 
            gap: 15px;
            justify-content: center;
            width: 100%;
            max-width: 1000px;
        }

        .circuit-region {
            flex: 1 1 350px; 
            background: white;
            border-radius: 15px;
            box-shadow: 0 4px 15px rgba(0,0,0,0.08);
            padding: 10px;
            display: flex;
            flex-direction: column;
            align-items: center;
            border-top: 5px solid #bdc3c7;
        }

        .region-1 { border-top-color: #3498db; }
        .region-2 { border-top-color: #27ae60; }

        .region-title {
            font-weight: bold;
            color: #7f8c8d;
            margin-bottom: 10px;
            font-size: 1.1rem;
        }

        /* 3. æ§åˆ¶é¢æ¿ */
        .controls { 
            display: flex; 
            flex-wrap: wrap; 
            justify-content: center; 
            gap: 5px; 
            margin-bottom: 10px;
        }

        button { 
            padding: 6px 10px; 
            font-size: 13px; 
            border: none; 
            border-radius: 6px; 
            font-weight: bold; 
            color: white;
            font-family: inherit;
            box-shadow: 0 2px 0 rgba(0,0,0,0.1);
            cursor: pointer;
        }
        button:active { transform: translateY(2px); box-shadow: none; }

        .btn-add { background-color: #3498db; }
        .btn-box { background-color: #9b59b6; }
        .btn-clear { background-color: #e74c3c; }

        /* 4. ç•«å¸ƒ */
        canvas { 
            display: block; 
            background: #fafafa; 
            border-radius: 8px;
            border: 2px dashed #e0e0e0; 
            touch-action: none; 
            cursor: crosshair;
            width: 100%; 
            height: auto;
        }

        /* ç‹€æ…‹åˆ— */
        .status-bar {
            margin-top: 8px;
            padding: 5px 10px;
            background: #eee;
            color: #555;
            border-radius: 15px;
            font-size: 12px;
            font-weight: bold;
            text-align: center;
            width: 90%;
            min-height: 24px;
            display: flex; align-items: center; justify-content: center;
        }
        .status-error { background: #ffcdd2; color: #c62828; animation: shake 0.4s; }
        @keyframes shake { 0%, 100% { transform: translateX(0); } 25% { transform: translateX(-3px); } 75% { transform: translateX(3px); } }

        /* åœ–ä¾‹ */
        .legend { margin-top: 20px; display: flex; flex-wrap: wrap; justify-content: center; gap: 12px; font-size: 12px; color: #555; }
        .dot { width: 10px; height: 10px; border-radius: 50%; display: inline-block; margin-right: 4px; border: 1px solid #ccc; }

        /* 5. ç­†è¨˜å€ (æ”¹ç‰ˆ) */
        .quiz-section {
            margin-top: 30px;
            background: white;
            padding: 20px;
            border-radius: 15px;
            width: 100%;
            max-width: 800px;
            border-top: 4px solid #8e44ad;
            box-shadow: 0 4px 10px rgba(0,0,0,0.05);
        }
        .quiz-section h3 { margin: 0 0 15px 0; color: #2c3e50; border-bottom: 1px solid #eee; padding-bottom: 10px; font-size: 1.2rem; }

        .quiz-unit {
            border: 1px solid #eee;
            border-radius: 8px;
            padding: 15px;
            margin-bottom: 15px;
            background: #f9f9f9;
        }

        .quiz-header {
            display: flex;
            align-items: center;
            justify-content: space-between;
            margin-bottom: 10px;
        }

        .quiz-label { 
            font-weight: bold; 
            color: #8e44ad; 
            font-size: 1.1rem;
        }

        .quiz-select { 
            padding: 6px; 
            border: 1px solid #ccc; 
            border-radius: 4px; 
            font-size: 1rem;
            min-width: 120px;
        }

        .quiz-reason {
            width: 100%;
            padding: 8px;
            border: 1px solid #ddd;
            border-radius: 6px;
            font-family: inherit;
            font-size: 0.95rem;
            resize: vertical;
            box-sizing: border-box;
            min-height: 50px;
        }
        .quiz-reason:focus { outline: 2px solid #3498db; border-color: transparent; }

    </style>
</head>
<body>

<div class="main-container">
    <h1>âš¡ï¸ ç¥ç§˜é›»å­ç›’</h1>
    <div class="intro">
<b>æ‚¨çš„ä»»å‹™ï¼š</b>æ‰¾å‡ºå››å€‹ç¥ç§˜é›»å­ç›’Aã€Bã€Cã€Dçš„çœŸæ­£èº«ä»½ã€‚ç›’å­è£¡åˆ†åˆ¥è£æœ‰ï¼šç‡ˆæ³¡ã€é›»ç·šã€é›»æ± å’Œç©ºç›’ã€‚<br>
<b>æ“ä½œæŒ‡å—ï¼š</b><br>
åŠ å…¥ï¼šé»æ“ŠæŒ‰éˆ•æ–°å¢å…ƒä»¶ ; ç§»å‹•ï¼šæŒ‰ä½ç‰©ä»¶æ‹–æ›³ï¼ˆ<br>
é€£ç·šï¼šæ‹–æ›³é»‘é»ï¼Œé€£ç·šè®Šç‚ºç¶ è‰²æ™‚æ”¾é–‹å³å¯é€£æ¥ ; åˆªé™¤ï¼šåœ¨ç‰©ä»¶ä¸Šå¿«é€Ÿé»å…©ä¸‹ <br>
é€éé€£æ¥é€™äº›ç¥ç§˜é›»å­ç›’ï¼Œæ¸¬è©¦å®ƒå€‘çš„åŠŸèƒ½ï¼Œå¾è€Œæ¨æ–·å®ƒå€‘çš„çœŸå¯¦èº«ä»½ã€‚    </div>
    <!-- å¯¦é©—å€å®¹å™¨ -->
    <div class="lab-wrapper">
        
        <!-- å·¦å€ (Region 1) -->
        <div class="circuit-region region-1">
            <div class="region-title">ğŸ”µ å¯¦é©—å€ 1</div>
            <div class="controls" id="ctrl-1">
                <button class="btn-add" onclick="sim1.add('battery')">â• é›»æ± </button>
                <button class="btn-add" onclick="sim1.add('bulb')">ğŸ’¡ ç‡ˆæ³¡</button>
                <button class="btn-clear" onclick="sim1.clear()">ğŸ—‘ï¸ æ¸…é™¤</button>
                <div style="flex-basis: 100%"></div>
                <button class="btn-box" onclick="sim1.add('box', 'A')">Box A</button>
                <button class="btn-box" onclick="sim1.add('box', 'B')">Box B</button>
                <button class="btn-box" onclick="sim1.add('box', 'C')">Box C</button>
                <button class="btn-box" onclick="sim1.add('box', 'D')">Box D</button>
            </div>
            <canvas id="canvas-1" width="400" height="350"></canvas>
            <div class="status-bar" id="status-1">ç­‰å¾…æ“ä½œ...</div>
        </div>

        <!-- å³å€ (Region 2) -->
        <div class="circuit-region region-2">
            <div class="region-title">ğŸŸ¢ å¯¦é©—å€ 2</div>
            <div class="controls" id="ctrl-2">
                <button class="btn-add" onclick="sim2.add('battery')">â• é›»æ± </button>
                <button class="btn-add" onclick="sim2.add('bulb')">ğŸ’¡ ç‡ˆæ³¡</button>
                <button class="btn-clear" onclick="sim2.clear()">ğŸ—‘ï¸ æ¸…é™¤</button>
                <div style="flex-basis: 100%"></div>
                <button class="btn-box" onclick="sim2.add('box', 'A')">Box A</button>
                <button class="btn-box" onclick="sim2.add('box', 'B')">Box B</button>
                <button class="btn-box" onclick="sim2.add('box', 'C')">Box C</button>
                <button class="btn-box" onclick="sim2.add('box', 'D')">Box D</button>
            </div>
            <canvas id="canvas-2" width="400" height="350"></canvas>
            <div class="status-bar" id="status-2">ç­‰å¾…æ“ä½œ...</div>
        </div>

    </div>

    <div class="legend">
        <div><span class="dot" style="background:#fff9c4"></span>æš—</div>
        <div><span class="dot" style="background:#ffeb3b"></span>æ­£å¸¸</div>
        <div><span class="dot" style="background:#fff; box-shadow:0 0 5px #999"></span>è¶…äº®</div>
        <div style="color:#c0392b"><span class="dot" style="background:#c0392b; border:none"></span>çŸ­è·¯</div>
    </div>

    <!-- ç­†è¨˜å€ -->
    <div class="quiz-section">
        <h3>ğŸ“ ç­†è¨˜ï¼šç¥ç§˜ç›’å­çš„çœŸæ­£èº«ä»½</h3>
        
        <div class="quiz-unit">
            <div class="quiz-header">
                <span class="quiz-label">Box A</span>
                <select class="quiz-select">
                    <option value="">æˆ‘è¦ºå¾—æ˜¯...</option>
                    <option value="battery">é›»æ± </option>
                    <option value="wire">é›»ç·š</option>
                    <option value="bulb">ç‡ˆæ³¡</option>
                    <option value="empty">ç©ºç›’</option>
                </select>
            </div>
            <textarea class="quiz-reason" placeholder="è«‹å¯«ä¸‹ä½ çš„ç†ç”±... (ä¾‹å¦‚ï¼šå› ç‚ºç‡ˆæ³¡è®Šå¾—...)"></textarea>
        </div>

        <div class="quiz-unit">
            <div class="quiz-header">
                <span class="quiz-label">Box B</span>
                <select class="quiz-select">
                    <option value="">æˆ‘è¦ºå¾—æ˜¯...</option>
                    <option value="battery">é›»æ± </option>
                    <option value="wire">é›»ç·š</option>
                    <option value="bulb">ç‡ˆæ³¡</option>
                    <option value="empty">ç©ºç›’</option>
                </select>
            </div>
            <textarea class="quiz-reason" placeholder="è«‹å¯«ä¸‹ä½ çš„ç†ç”±..."></textarea>
        </div>

        <div class="quiz-unit">
            <div class="quiz-header">
                <span class="quiz-label">Box C</span>
                <select class="quiz-select">
                    <option value="">æˆ‘è¦ºå¾—æ˜¯...</option>
                    <option value="battery">é›»æ± </option>
                    <option value="wire">é›»ç·š</option>
                    <option value="bulb">ç‡ˆæ³¡</option>
                    <option value="empty">ç©ºç›’</option>
                </select>
            </div>
            <textarea class="quiz-reason" placeholder="è«‹å¯«ä¸‹ä½ çš„ç†ç”±..."></textarea>
        </div>

        <div class="quiz-unit">
            <div class="quiz-header">
                <span class="quiz-label">Box D</span>
                <select class="quiz-select">
                    <option value="">æˆ‘è¦ºå¾—æ˜¯...</option>
                    <option value="battery">é›»æ± </option>
                    <option value="wire">é›»ç·š</option>
                    <option value="bulb">ç‡ˆæ³¡</option>
                    <option value="empty">ç©ºç›’</option>
                </select>
            </div>
            <textarea class="quiz-reason" placeholder="è«‹å¯«ä¸‹ä½ çš„ç†ç”±..."></textarea>
        </div>

    </div>
</div>

<script>
    // --- å°è£å¾Œçš„é›»è·¯æ¨¡æ“¬å™¨é¡åˆ¥ ---
    class CircuitSimulator {
        constructor(canvasId, statusId) {
            this.canvas = document.getElementById(canvasId);
            this.ctx = this.canvas.getContext('2d');
            this.statusBar = document.getElementById(statusId);
            
            this.components = [];
            this.wires = [];
            this.isShortCircuit = false;
            
            // Interaction State
            this.isDragging = false;
            this.dragTarget = null;
            this.wireStartNode = null;
            this.mouseX = 0;
            this.mouseY = 0;
            this.snapNode = null;
            this.lastTapTime = 0;
            this.SNAP_RADIUS = 40;

            // Bind Events
            this.bindEvents();
            
            // Start Loop
            this.animate();
        }

        // --- å…¬é–‹æ–¹æ³• ---
        add(type, subType = null) {
            // é™åˆ¶æª¢æŸ¥
            if (type === 'battery' && this.components.some(c => c.type === 'battery')) {
                this.updateStatus("é™åˆ¶ï¼šåªèƒ½æœ‰ä¸€å€‹é›»æ± ", 'warn'); return;
            }
            if (type === 'bulb' && this.components.some(c => c.type === 'bulb')) {
                this.updateStatus("é™åˆ¶ï¼šåªèƒ½æœ‰ä¸€å€‹ç‡ˆæ³¡", 'warn'); return;
            }
            if (type === 'box') {
                let oldBox = this.components.find(c => c.type === 'box');
                if (oldBox) this.removeComponent(oldBox);
            }

            let cx = this.canvas.width / 2;
            let cy = this.canvas.height / 2;
            if(type==='battery') cy -= 60;
            if(type==='bulb') cy += 60;

            let existing = (type !== 'box') ? this.components.find(c => c.type === type) : null;
            if (existing) {
                existing.x = cx; existing.y = cy;
                this.updateStatus(`å·²é‡ç½®ä½ç½®`);
            } else {
                this.components.push(new Component(type, cx, cy, subType));
            }
            this.checkCircuit();
        }

        clear() {
            this.components = [];
            this.wires = [];
            this.checkCircuit();
            this.updateStatus("å·²æ¸…é™¤");
        }

        // --- å…§éƒ¨é‚è¼¯ ---
        updateStatus(msg, type = 'normal') {
            this.statusBar.innerText = msg;
            this.statusBar.className = "status-bar";
            if (type === 'error') this.statusBar.classList.add('status-error');
            if (type !== 'normal' && type !== 'warn') setTimeout(() => this.statusBar.className = "status-bar", 2500);
        }

        removeComponent(comp) {
            this.components = this.components.filter(c => c.id !== comp.id);
            this.wires = this.wires.filter(w => w.startCompId !== comp.id && w.endCompId !== comp.id);
            this.checkCircuit();
        }

        // --- ç‰©ç†è¨ˆç®— ---
        checkCircuit() {
            this.isShortCircuit = false;
            this.components.forEach(c => { c.brightness = 0; c.isOverheated = false; });
            this.wires.forEach(w => w.isHot = false);

            let powerSources = this.components.filter(c => c.type === 'battery' || (c.type === 'box' && c.subType === 'A'));
            if (powerSources.length === 0) { 
                // Removed explicit hint "è«‹åŠ å…¥é›»æº", using neutral text
                this.updateStatus("ç­‰å¾…æ“ä½œ..."); 
                return; 
            }
            this.updateStatus("å¯¦é©—ä¸­...");

            // 1. çŸ­è·¯æª¢æ¸¬
            for (let source of powerSources) {
                let result = this.findShortLoop(source.id, 1, [], new Set(), source.id, 1.5);
                if (result && Math.abs(result.netVoltage) > 0.1) {
                    this.isShortCircuit = true;
                    source.isOverheated = true;
                    result.wires.forEach(w => w.isHot = true);
                    this.updateStatus("âš ï¸ çŸ­è·¯ï¼é›»è·¯éç†±ï¼", 'error');
                } 
                // Removed: else if (result && Math.abs(result.netVoltage) <= 0.1) { "é›»å£“æŠµéŠ·" }
            }
            if (this.isShortCircuit) return;

            // 2. æ­£å¸¸é›»è·¯
            for (let source of powerSources) {
                this.solveCircuit(source.id, 1, 1.5, 0, [], new Set(), source.id);
            }
        }

        findShortLoop(currId, currNode, path, visited, srcId, voltage) {
            let conns = this.wires.filter(w => 
                (w.startCompId === currId && w.startNodeIdx === currNode) ||
                (w.endCompId === currId && w.endNodeIdx === currNode)
            );
            for(let w of conns) {
                if(visited.has(w)) continue;
                let nextId = (w.startCompId === currId) ? w.endCompId : w.startCompId;
                let nextNode = (w.startCompId === currId) ? w.endNodeIdx : w.startNodeIdx;
                let nextComp = this.components.find(c => c.id === nextId);
                if(!nextComp) continue;

                if(nextComp.id === srcId && nextNode === 0) { path.push(w); return {wires:path, netVoltage:voltage}; }
                if(nextComp.id === srcId && nextNode === 1) continue;

                let isCond = false; let dV = 0;
                if(nextComp.type==='box' && nextComp.subType==='C') isCond=true;
                if(nextComp.type==='battery' || (nextComp.type==='box' && nextComp.subType==='A')) {
                    isCond=true; dV = (nextNode===0)?1.5:-1.5;
                }

                if(isCond) {
                    let newV = new Set(visited); newV.add(w);
                    let newP = [...path, w];
                    let exit = (nextNode===0)?1:0;
                    if(newP.length<10) {
                        let res = this.findShortLoop(nextComp.id, exit, newP, newV, srcId, voltage+dV);
                        if(res) return res;
                    }
                }
            }
            return null;
        }

        solveCircuit(currId, currNode, V, R, path, visited, srcId) {
            let conns = this.wires.filter(w => 
                (w.startCompId === currId && w.startNodeIdx === currNode) ||
                (w.endCompId === currId && w.endNodeIdx === currNode)
            );
            conns.forEach(w => {
                if(visited.has(w)) return;
                let nextId = (w.startCompId === currId) ? w.endCompId : w.startCompId;
                let nextNode = (w.startCompId === currId) ? w.endNodeIdx : w.startNodeIdx;
                let nextComp = this.components.find(c => c.id === nextId);
                if(!nextComp) return;

                if(nextComp.id === srcId && nextNode === 0) {
                    let I = (R>0)?V/R:0;
                    if(I<0.01) {
                        // Removed voltage cancel hint
                        I=0;
                    }
                    path.forEach(item => { if(item.type==='bulb') item.brightness = Math.max(item.brightness, I); });
                    return;
                }
                if(nextComp.id === srcId && nextNode === 1) return;

                let pass = false; let dV=0; let dR=0;
                if(nextComp.type==='bulb') { pass=true; dR=1; }
                else if(nextComp.type==='box') {
                    if(nextComp.subType==='A') { pass=true; dV=(nextNode===0)?1.5:-1.5; }
                    else if(nextComp.subType==='C') { pass=true; dR=0; }
                    else if(nextComp.subType==='D') { pass=true; dR=1; }
                }
                else if(nextComp.type==='battery') { pass=true; dV=(nextNode===0)?1.5:-1.5; }

                if(pass) {
                    let exit = (nextNode===0)?1:0;
                    let newP = [...path, nextComp];
                    let newV = new Set(visited); newV.add(w);
                    if(path.length<10) this.solveCircuit(nextComp.id, exit, V+dV, R+dR, newP, newV, srcId);
                }
            });
        }

        // --- äº‹ä»¶è™•ç† ---
        getPos(e) {
            const rect = this.canvas.getBoundingClientRect();
            const sx = this.canvas.width / rect.width;
            const sy = this.canvas.height / rect.height;
            let cx, cy;
            if(e.touches && e.touches.length>0) { cx=e.touches[0].clientX; cy=e.touches[0].clientY; }
            else if(e.changedTouches && e.changedTouches.length>0) { cx=e.changedTouches[0].clientX; cy=e.changedTouches[0].clientY; }
            else { cx=e.clientX; cy=e.clientY; }
            return { x:(cx-rect.left)*sx, y:(cy-rect.top)*sy };
        }

        handleStart(e) {
            if(e.target===this.canvas) e.preventDefault();
            const p = this.getPos(e);
            const now = new Date().getTime();
            
            // Double Tap
            let hitC = this.components.findIndex(c => c.isHit(p.x, p.y));
            if(hitC>=0 && (now - this.lastTapTime)<300) {
                this.removeComponent(this.components[hitC]);
                this.lastTapTime=0; return;
            }
            let hitW = this.wires.findIndex(w => this.checkWireHit(w, p.x, p.y));
            if(hitW>=0 && (now - this.lastTapTime)<300) {
                this.wires.splice(hitW, 1);
                this.checkCircuit();
                this.lastTapTime=0; return;
            }
            this.lastTapTime = now;

            // Drag/Wire
            for(let c of this.components) {
                let n = c.checkNode(p.x, p.y, this.SNAP_RADIUS);
                if(n) { this.isDragging=true; this.wireStartNode=n; return; }
            }
            if(hitC>=0) { this.isDragging=true; this.dragTarget=this.components[hitC]; }
        }

        handleMove(e) {
            if(!this.isDragging) return;
            if(e.target===this.canvas) e.preventDefault();
            const p = this.getPos(e);
            this.mouseX = p.x; this.mouseY = p.y;

            if(this.dragTarget) {
                this.dragTarget.x = p.x; this.dragTarget.y = p.y;
                this.checkCircuit();
            }

            this.snapNode = null;
            if(this.wireStartNode) {
                for(let c of this.components) {
                    let n = c.checkNode(p.x, p.y, this.SNAP_RADIUS);
                    if(n && (n.parentId!==this.wireStartNode.parentId || n.nodeIndex!==this.wireStartNode.nodeIndex)) {
                        this.snapNode = n; break;
                    }
                }
            }
        }

        handleEnd(e) {
            if(e.target===this.canvas) e.preventDefault();
            if(this.isDragging && this.wireStartNode) {
                let end = this.snapNode;
                if(!end) {
                    const p = this.getPos(e);
                    for(let c of this.components) {
                        end = c.checkNode(p.x, p.y, this.SNAP_RADIUS);
                        if(end) break;
                    }
                }
                
                if(end && end.parentId !== this.wireStartNode.parentId) {
                    let exists = this.wires.some(w => 
                        (w.startCompId===this.wireStartNode.parentId && w.startNodeIdx===this.wireStartNode.nodeIndex &&
                         w.endCompId===end.parentId && w.endNodeIdx===end.nodeIndex) ||
                        (w.endCompId===this.wireStartNode.parentId && w.endNodeIdx===this.wireStartNode.nodeIndex &&
                         w.startCompId===end.parentId && w.startNodeIdx===end.nodeIndex)
                    );
                    if(!exists) {
                        this.wires.push({
                            startCompId: this.wireStartNode.parentId, startNodeIdx: this.wireStartNode.nodeIndex,
                            endCompId: end.parentId, endNodeIdx: end.nodeIndex, isHot: false
                        });
                        this.checkCircuit();
                    }
                }
            }
            this.isDragging = false; this.dragTarget = null; this.wireStartNode = null; this.snapNode = null;
        }

        bindEvents() {
            const c = this.canvas;
            c.addEventListener('mousedown', (e)=>this.handleStart(e));
            c.addEventListener('mousemove', (e)=>this.handleMove(e));
            c.addEventListener('mouseup', (e)=>this.handleEnd(e));
            c.addEventListener('touchstart', (e)=>this.handleStart(e), {passive:false});
            c.addEventListener('touchmove', (e)=>this.handleMove(e), {passive:false});
            c.addEventListener('touchend', (e)=>this.handleEnd(e), {passive:false});
        }

        checkWireHit(w, mx, my) {
            let c1 = this.components.find(c=>c.id===w.startCompId);
            let c2 = this.components.find(c=>c.id===w.endCompId);
            if(!c1||!c2) return false;
            let p1 = c1.getWorldNode(w.startNodeIdx);
            let p2 = c2.getWorldNode(w.endNodeIdx);
            let d = Math.abs((p2.y-p1.y)*mx - (p2.x-p1.x)*my + p2.x*p1.y - p2.y*p1.x) / Math.sqrt((p2.y-p1.y)**2 + (p2.x-p1.x)**2);
            return d < 15;
        }

        animate() {
            this.draw();
            requestAnimationFrame(()=>this.animate());
        }

        draw() {
            let ctx = this.ctx;
            ctx.clearRect(0, 0, this.canvas.width, this.canvas.height);

            // Wires
            ctx.lineCap = 'round'; ctx.lineJoin = 'round';
            this.wires.forEach(w => {
                let c1 = this.components.find(c=>c.id===w.startCompId);
                let c2 = this.components.find(c=>c.id===w.endCompId);
                if(c1&&c2) {
                    let p1 = c1.getWorldNode(w.startNodeIdx);
                    let p2 = c2.getWorldNode(w.endNodeIdx);
                    ctx.beginPath(); ctx.moveTo(p1.x, p1.y); ctx.lineTo(p2.x, p2.y);
                    if(w.isHot) { ctx.strokeStyle='#c0392b'; ctx.lineWidth=8; ctx.shadowColor='#e74c3c'; ctx.shadowBlur=15; }
                    else { ctx.strokeStyle='#34495e'; ctx.lineWidth=5; ctx.shadowBlur=0; }
                    ctx.stroke();
                    ctx.shadowBlur=0;
                    ctx.fillStyle = w.isHot?'#c0392b':'#7f8c8d';
                    ctx.beginPath(); ctx.arc(p1.x, p1.y, 6, 0, Math.PI*2); ctx.fill();
                    ctx.beginPath(); ctx.arc(p2.x, p2.y, 6, 0, Math.PI*2); ctx.fill();
                }
            });

            // Preview
            if(this.isDragging && this.wireStartNode) {
                let tx = this.mouseX; let ty = this.mouseY;
                let col = '#95a5a6'; let lw = 4;
                if(this.snapNode) { tx=this.snapNode.x; ty=this.snapNode.y; col='#2ecc71'; lw=6; }
                
                ctx.beginPath(); ctx.moveTo(this.wireStartNode.x, this.wireStartNode.y); ctx.lineTo(tx, ty);
                ctx.strokeStyle=col; ctx.lineWidth=lw; ctx.setLineDash([10,10]); ctx.stroke(); ctx.setLineDash([]);
                
                this.components.forEach(c => {
                    c.nodes.forEach((n, idx) => {
                        if(c.id===this.wireStartNode.parentId && idx===this.wireStartNode.nodeIndex) return;
                        let wn = c.getWorldNode(idx);
                        ctx.beginPath(); ctx.arc(wn.x, wn.y, 15, 0, Math.PI*2);
                        ctx.strokeStyle='rgba(46, 204, 113, 0.4)'; ctx.lineWidth=2; ctx.stroke();
                    });
                });
            }

            // Components
            this.components.forEach(c => {
                ctx.save();
                if(c.isOverheated) ctx.translate(c.x+(Math.random()-0.5)*5, c.y+(Math.random()-0.5)*5);
                else ctx.translate(c.x, c.y);
                c.draw(ctx);
                ctx.restore();
            });
        }
    }

    // --- å…ƒä»¶ç¹ªåœ–èˆ‡è³‡æ–™ ---
    class Component {
        constructor(type, x, y, subType) {
            this.id = Math.random().toString(36);
            this.type = type; this.subType = subType;
            this.x = x; this.y = y;
            this.brightness = 0; this.isOverheated = false;
            
            if (type === 'battery') {
                this.nodes = [{x:-50,y:0}, {x:50,y:0}]; // å·¦-, å³+
                this.w = 100; this.h = 40;
            } else if (type === 'bulb') {
                this.nodes = [{x:0,y:35}, {x:20,y:20}];
                this.w = 40; this.h = 70;
            } else if (type === 'box') {
                this.nodes = [{x:-55,y:0}, {x:55,y:0}];
                this.w = 110; this.h = 60;
            }
        }

        getWorldNode(idx) { return { x: this.x + this.nodes[idx].x, y: this.y + this.nodes[idx].y, parentId: this.id, nodeIndex: idx }; }
        
        checkNode(mx, my, r) {
            for(let i=0; i<this.nodes.length; i++) {
                let wn = this.getWorldNode(i);
                if(Math.sqrt((mx-wn.x)**2 + (my-wn.y)**2) < r) return wn;
            }
            return null;
        }
        
        isHit(mx, my) { return mx > this.x - this.w/2 && mx < this.x + this.w/2 && my > this.y - this.h/2 && my < this.y + this.h/2; }

        draw(ctx) {
            if(this.type === 'battery') {
                ctx.fillStyle = this.isOverheated ? '#e74c3c' : '#7f8c8d';
                ctx.fillRect(-50, -20, 100, 40);
                ctx.fillStyle = '#f39c12'; ctx.fillRect(-40, -20, 70, 40); ctx.strokeRect(-50, -20, 100, 40);
                ctx.fillStyle = '#bdc3c7'; ctx.fillRect(50, -10, 8, 20); ctx.strokeRect(50, -10, 8, 20);
                ctx.fillStyle = 'black'; ctx.font="bold 18px Arial"; ctx.fillText("+", 30, 8); ctx.fillText("-", -30, 6);
            } else if (this.type === 'bulb') {
                ctx.fillStyle = '#bdc3c7'; ctx.fillRect(-15, 15, 30, 25);
                ctx.strokeStyle='#555'; ctx.beginPath(); ctx.moveTo(-15,20); ctx.lineTo(15,25); ctx.moveTo(-15,25); ctx.lineTo(15,30); ctx.stroke();
                ctx.fillStyle = '#2c3e50'; ctx.beginPath(); ctx.moveTo(-10,40); ctx.lineTo(10,40); ctx.lineTo(6,46); ctx.lineTo(-6,46); ctx.fill();
                
                let col = '230,230,230'; let blur=0; let alpha=0.3;
                if(this.brightness>0.1) {
                    if(this.brightness<1.0) { col='255,249,196'; alpha=0.9; blur=15; }
                    else if(this.brightness<2.0) { col='255,235,59'; alpha=1; blur=30; }
                    else { col='255,255,255'; alpha=1; blur=50; }
                }
                ctx.shadowColor=`rgb(${col})`; ctx.shadowBlur=blur; ctx.fillStyle=`rgba(${col},${alpha})`;
                ctx.beginPath(); ctx.arc(0, -10, 25, 0, Math.PI*2); ctx.fill();
                ctx.shadowBlur=0; ctx.strokeStyle='#bdc3c7'; ctx.lineWidth=1; ctx.stroke();
                
                ctx.strokeStyle=(this.brightness>0.1)?'#fff':'#7f8c8d'; ctx.lineWidth=3;
                ctx.beginPath(); ctx.moveTo(-8,15); ctx.lineTo(-8,-10); ctx.lineTo(0,-5); ctx.lineTo(8,-10); ctx.lineTo(8,15); ctx.stroke();
            } else if (this.type === 'box') {
                ctx.fillStyle = this.isOverheated ? '#c0392b' : '#9b59b6';
                ctx.fillRect(-55, -30, 110, 60);
                ctx.lineWidth = 2; ctx.strokeStyle='white'; ctx.strokeRect(-55, -30, 110, 60);
                ctx.fillStyle = 'white'; ctx.font="bold 22px Arial"; ctx.fillText(this.subType, -8, 8);
            }

            // Draw Nodes
            this.nodes.forEach((n, i) => {
                let isPos = (this.type==='battery' && i===1);
                let col = isPos ? '#c0392b' : '#333';
                ctx.beginPath(); ctx.arc(n.x, n.y, 7, 0, Math.PI*2);
                ctx.fillStyle=col; ctx.fill(); ctx.strokeStyle='#fff'; ctx.lineWidth=2; ctx.stroke();
            });
        }
    }

    // --- åˆå§‹åŒ–å…©å€‹æ¨¡æ“¬å™¨ ---
    const sim1 = new CircuitSimulator('canvas-1', 'status-1');
    const sim2 = new CircuitSimulator('canvas-2', 'status-2');

</script>
</body>
</html>
